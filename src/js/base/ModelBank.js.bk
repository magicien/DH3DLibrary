'use strict'

/**
 * ModelBank class
 * @access public
 */
export class ModelBank {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    /** @type {Map} */
    this._models = new Map()
    /** @type {Map} */
    this._loadingModels = new Map()
    /** @type {Map} */
    this._promises = new Map()
    /** @type {Map} */
    this._modelsOfContext = new Map()
    /** @type {Array} */
    this._modelReaders = []
  }

  addModelReader(modelReader) {
    this._modelReaders.push(modelReader)
  }

  getFileID(file) {
    if(!(file instanceof File)){
      return ''
    }
    //return 'FILE:' + file.name + '_' + file.size + '_' + file.lastModifiedDate
    return `FILE:${file.name}_${file.size}_${file.lastModifiedDate}`
  }

  getModel(modelFile, options) {
    if(modelFile instanceof File){
      return this.getModelFromFile(modelFile, options)
    }
   
    /*
    let model = this._models.get(modelFile)
    if(model){
      const m = model.clone()
      if(options && options.onload) {
        m.onload = options.onload
      }else{
        m.onload = null
      }

      if(m.loaded){
        if(m.onload){
          m.onload()
        }
      }else{
        const arr = this._loadingModels.get(modelFile)
        arr.push(m)
      }
      return m
    }
    */
    const model = this._models.get(modelFile)
    if(model){
      const m = model.clone()
      return Promise.resolve(m)
    }

    /*
    //this._modelReaders.find( (readerClass) => {
    this._modelReaders.some( (readerClass) => {
      const reader = new readerClass()
      model = reader.readModel(modelFile)

      if(model)
        return true
      
      return false
    })
    */
    let promise = null
    this._modelReaders.some((readerClass) => {
      if(readerClass.canRead(modelFile)){
        const reader = new readerClass()
        promise = reader.readModel(modelFile)
        return true
      }
      return false
    })

    /*
    if(model){
      const obj = this
      model.onload = () => { obj.onloadModel(model) }

      model.hashName = modelFile
      this._models.set(modelFile, model)

      const arr = []
      const m = model.clone()
      if(options && options.onload) {
        m.onload = options.onload
      }else{
        m.onload = null
      }
      arr.push(m)
      this._loadingModels.set(model.hashName, arr)

      return m
    }
    return null
    */
    if(promise){
      return promise.then((loadedModel) => {
        // FIXME: don't use model.hashName
        loadedModel.hashName = modelFile

        this._models.set(modelFile, loadedModel)
        return loadedModel.clone()   
      })
    }

    return Promise.reject(`can't read file: ${modelFile}`)
  }

  getModelFromFile(modelFile, options) {
    const id = this.getFileID(modelFile)
    const model = this._models.get(id)

    /*
    if(model){
      const m = model.clone()
      if(options && options.onload) {
        m.onload = options.onload
      }else{
        m.onload = null
      }

      if(m.loaded){
        if(m.onload){
          m.onload()
        }
      }else{
        const arr = this._loadingModels.get(modelFile)
        arr.push(m)
      }
      return m
    }
    */
    if(model){
      const m = model.clone()
      return Promise.resolve(m)
    }

    /*
    //this._modelReaders.find( (readerClass) => {
    this._modelReaders.some( (readerClass) => {
      const reader = new readerClass()
      model = reader.readModelFromFile(modelFile)

      if(model)
        return true

      return false
    })
    */
    let promise = null
    this._modelReaders.some((readerClass) => {
      if(readerClass.canRead(modelFile)){
        const reader = new readerClass()
        promise = reader.readModelFromFile(modelFile)
        return true
      }
      return false
    })
    
    /*
    if(model){
      const obj = this
      model.onload = () => { obj.onloadModel(model) }

      model.hashName = id
      this._models.set(id, model)

      const arr = []
      const m = model.clone()
      if(options && options.onload){
        m.onload = options.onload
      }else{
        m.onload = null
      }
      arr.push(m)
      this._loadingModels.set(model.hashName, arr)

      return m
    }

    return null
    */
    if(promise){
      return promise.then((loadedModel) => {
        // FIXME: don't use model.hashName
        loadedModel.hashName = id

        this._models.set(id, loadedModel)

        let newModel = loadedModel.clone()

        return newModel
      })
    }

    return Promise.reject(`can't read file: ${modelFile}`)
  }

/*
  onloadModel(model) {
    model.loaded = true

    const arr = this._loadingModels.get(model.hashName)
    if(arr){
      arr.forEach( (m) => {
        m.loaded = true
        if(m.onload){
          m.copy(model)
          m.onload()
        }
      })
    }
  }
*/

  getModelForRenderer(modelFile, renderer) {
    let models = this._modelsOfContext.get(modelFile)
    if(!models){
      models = new Map()
      this._modelsOfContext.set(modelFile, models)
    }

    const gl = renderer.getContext()
    const model = models.get(gl)
    if(model){
      return Promise.resolve(model)
    }

    const promise = this.getModel(modelFile).then((orgModel) => {
      // vertex buffer
      orgModel.vertexBuffer = gl.createBuffer()
      gl.bindBuffer(gl.ARRAY_BUFFER, orgModel.vertexBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, renderer.getVertexData(orgModel), gl.DYNAMIC_DRAW)

      // index buffer
      orgModel.renderGroupArray.forEach( (group) => {
        group.indexBuffer = gl.createBuffer()
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, group.indexBuffer)
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, group.getIndexData(), gl.STATIC_DRAW)
      })

      orgModel.renderer = renderer
      models.set(gl, orgModel)

      return orgModel.clone()
    })

    return promise
  }
}

// for singleton
export default new ModelBank()

